"""Flight failure analysis system.

This module provides comprehensive post-crash analysis to help pilots
understand what went wrong and learn from their mistakes.

Typical usage:
    analyzer = FailureAnalyzer()
    analyzer.record_event(120.5, "Low fuel warning")
    analyzer.record_warning(180.0, "Fuel exhausted")

    # At crash
    analysis = analyzer.analyze_failure(failure_snapshot, impact_snapshot)
    report = analyzer.generate_report(analysis)
    print(report)
"""

from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum


class FailureType(Enum):
    """Types of flight failures.

    Different failure types require different lessons and have different
    primary causes.
    """

    FUEL_EXHAUSTION = "fuel_exhaustion"
    ENGINE_FAILURE = "engine_failure"
    ELECTRICAL_FAILURE = "electrical_failure"
    CONTROLLED_FLIGHT_INTO_TERRAIN = "cfit"
    STALL_SPIN = "stall_spin"
    OVERSPEED = "overspeed"
    STRUCTURAL_FAILURE = "structural_failure"
    HARD_LANDING = "hard_landing"
    GEAR_UP_LANDING = "gear_up_landing"
    RUNWAY_OVERRUN = "runway_overrun"
    MID_AIR_COLLISION = "mid_air_collision"


class SurvivabilityLevel(Enum):
    """Impact survivability assessment levels.

    Based on G-forces, impact angle, and aircraft configuration.
    """

    UNSURVIVABLE = "unsurvivable"  # > 20 G or catastrophic damage
    LIKELY_FATAL = "likely_fatal"  # 10-20 G, serious injuries expected
    SERIOUS_INJURY = "serious_injury"  # 5-10 G, major injuries likely
    MINOR_INJURY = "minor_injury"  # 2-5 G, minor injuries possible
    SURVIVABLE = "survivable"  # < 2 G, likely to survive


@dataclass
class FailureSnapshot:
    """Snapshot of aircraft state at a specific moment.

    Captures all relevant state for failure analysis.

    Attributes:
        time: Timestamp of snapshot
        position: Position (latitude, longitude, altitude_msl)
        velocity: Velocity vector (vx, vy, vz) in ft/s
        airspeed_knots: Indicated airspeed in knots
        ground_speed_knots: Ground speed in knots
        vertical_speed_fpm: Vertical speed in feet per minute
        heading: Magnetic heading in degrees
        pitch: Pitch attitude in degrees
        roll: Roll attitude in degrees
        engine_state: Engine state dictionary
        electrical_state: Electrical state dictionary
        fuel_state: Fuel state dictionary
        control_inputs: Control input dictionary
    """

    time: datetime
    position: tuple[float, float, float]  # (lat, lon, alt_msl)
    velocity: tuple[float, float, float]  # (vx, vy, vz) ft/s
    airspeed_knots: float
    ground_speed_knots: float
    vertical_speed_fpm: float
    heading: float
    pitch: float
    roll: float
    engine_state: dict
    electrical_state: dict
    fuel_state: dict
    control_inputs: dict


@dataclass
class FailureAnalysis:
    """Complete failure analysis report.

    Generated by FailureAnalyzer after crash to explain what happened
    and provide learning opportunities.

    Attributes:
        failure_type: Primary failure classification
        primary_cause: Human-readable primary cause description
        contributing_factors: List of contributing factors
        failure_snapshot: Aircraft state at moment of failure
        impact_snapshot: Aircraft state at impact
        impact_force_g: Impact G-force
        survivability: Survivability assessment
        lessons_learned: List of lessons for pilot
        timeline: Timeline of events (time_offset, description)
        flight_duration: Total flight duration in seconds
    """

    failure_type: FailureType
    primary_cause: str
    contributing_factors: list[str]
    failure_snapshot: FailureSnapshot
    impact_snapshot: FailureSnapshot
    impact_force_g: float
    survivability: SurvivabilityLevel
    lessons_learned: list[str]
    timeline: list[tuple[float, str]]  # (time_offset_seconds, event_description)
    flight_duration: float  # seconds


class FailureAnalyzer:
    """Analyzes flight failures and generates detailed educational reports.

    Tracks flight events, warnings, and state throughout the flight,
    then generates comprehensive analysis after crash explaining what
    went wrong and how to avoid it in the future.

    No forgiveness - failures are realistic and analysis is honest.
    """

    def __init__(self):
        """Initialize failure analyzer."""
        self.event_timeline: list[tuple[float, str]] = []
        self.warnings_given: list[tuple[float, str]] = []
        self.flight_start_time: datetime | None = None

    def start_flight(self, start_time: datetime | None = None) -> None:
        """Start flight tracking.

        Args:
            start_time: Flight start time (defaults to now)
        """
        self.flight_start_time = start_time or datetime.now()
        self.event_timeline = []
        self.warnings_given = []
        self.record_event(0.0, "Flight started")

    def record_event(self, time_offset: float, event: str) -> None:
        """Record event in flight timeline.

        Args:
            time_offset: Time since flight start in seconds
            event: Event description
        """
        self.event_timeline.append((time_offset, event))

    def record_warning(self, time_offset: float, warning: str) -> None:
        """Record warning given to pilot.

        Args:
            time_offset: Time since flight start in seconds
            warning: Warning message given
        """
        self.warnings_given.append((time_offset, warning))
        self.record_event(time_offset, f"WARNING: {warning}")

    def analyze_failure(
        self, failure_snapshot: FailureSnapshot, impact_snapshot: FailureSnapshot
    ) -> FailureAnalysis:
        """Analyze flight failure and generate comprehensive report.

        Args:
            failure_snapshot: Aircraft state at moment of failure detection
            impact_snapshot: Aircraft state at impact

        Returns:
            FailureAnalysis with complete failure breakdown
        """
        # Determine failure type
        failure_type = self._determine_failure_type(failure_snapshot, impact_snapshot)

        # Determine primary cause
        primary_cause = self._determine_primary_cause(failure_type, failure_snapshot)

        # Analyze contributing factors
        contributing_factors = self._analyze_contributing_factors(failure_snapshot, impact_snapshot)

        # Calculate impact force and survivability
        impact_g = self._calculate_impact_force(impact_snapshot)
        survivability = self._assess_survivability(impact_g, impact_snapshot)

        # Generate lessons learned
        lessons = self._generate_lessons(
            failure_type, failure_snapshot, impact_snapshot, self.warnings_given
        )

        # Calculate flight duration
        if self.flight_start_time:
            duration = (impact_snapshot.time - self.flight_start_time).total_seconds()
        else:
            duration = 0.0

        return FailureAnalysis(
            failure_type=failure_type,
            primary_cause=primary_cause,
            contributing_factors=contributing_factors,
            failure_snapshot=failure_snapshot,
            impact_snapshot=impact_snapshot,
            impact_force_g=impact_g,
            survivability=survivability,
            lessons_learned=lessons,
            timeline=self.event_timeline,
            flight_duration=duration,
        )

    def _determine_failure_type(
        self, failure_snapshot: FailureSnapshot, impact_snapshot: FailureSnapshot
    ) -> FailureType:
        """Determine primary failure type from aircraft state."""
        # Check fuel exhaustion
        fuel = failure_snapshot.fuel_state
        if fuel.get("total_usable_gallons", 0) <= 0.0:
            return FailureType.FUEL_EXHAUSTION

        # Check engine failure (in flight)
        engine = failure_snapshot.engine_state
        altitude_agl = failure_snapshot.position[2] - 0  # Simplified (should use terrain)
        if not engine.get("running", False) and altitude_agl > 100:
            return FailureType.ENGINE_FAILURE

        # Check stall/spin (check before CFIT - higher priority)
        if (
            impact_snapshot.airspeed_knots < 45  # Below stall speed
            and abs(impact_snapshot.roll) > 30  # Significant bank
        ):
            return FailureType.STALL_SPIN

        # Check hard landing (check before CFIT - distinguish landing accidents)
        if abs(impact_snapshot.vertical_speed_fpm) > 600 and altitude_agl < 100:
            return FailureType.HARD_LANDING

        # Check CFIT (flying into terrain while under control)
        if (
            impact_snapshot.vertical_speed_fpm < -500
            and abs(impact_snapshot.pitch) < 15
            and abs(impact_snapshot.roll) < 30
            and altitude_agl > 100  # Not landing
        ):
            return FailureType.CONTROLLED_FLIGHT_INTO_TERRAIN

        # Check gear-up landing
        if not impact_snapshot.control_inputs.get("gear", True) and altitude_agl < 10:
            return FailureType.GEAR_UP_LANDING

        # Default to engine failure
        return FailureType.ENGINE_FAILURE

    def _determine_primary_cause(self, failure_type: FailureType, snapshot: FailureSnapshot) -> str:
        """Generate human-readable primary cause description."""
        if failure_type == FailureType.FUEL_EXHAUSTION:
            return "Fuel Exhaustion - All fuel tanks empty"

        elif failure_type == FailureType.ENGINE_FAILURE:
            engine = snapshot.engine_state
            oil_pressure = engine.get("oil_pressure_psi", 0)
            oil_temp = engine.get("oil_temperature_c", 0)

            if oil_pressure < 10:
                return "Engine Failure - Loss of oil pressure (engine seizure likely)"
            elif oil_temp > 120:
                return "Engine Failure - Engine overheated"
            else:
                return "Engine Failure - Unknown mechanical failure"

        elif failure_type == FailureType.CONTROLLED_FLIGHT_INTO_TERRAIN:
            return "Controlled Flight Into Terrain - Spatial disorientation or navigation error"

        elif failure_type == FailureType.STALL_SPIN:
            return "Aerodynamic Stall/Spin - Airspeed below stall speed with excessive bank"

        elif failure_type == FailureType.HARD_LANDING:
            return "Hard Landing - Excessive descent rate at touchdown"

        elif failure_type == FailureType.GEAR_UP_LANDING:
            return "Gear-Up Landing - Landing gear not extended"

        return str(failure_type.value).replace("_", " ").title()

    def _analyze_contributing_factors(
        self, failure_snapshot: FailureSnapshot, impact_snapshot: FailureSnapshot
    ) -> list[str]:
        """Identify contributing factors to the failure."""
        factors = []

        # Check if warnings were ignored
        if len(self.warnings_given) > 0:
            factors.append(f"Pilot ignored {len(self.warnings_given)} warning(s)")

        # Fuel management issues
        fuel = failure_snapshot.fuel_state
        if fuel.get("total_usable_gallons", 0) < 5.0:
            factors.append("Low fuel state before failure")

        # Check for fuel imbalance
        tanks = fuel.get("tanks", {})
        if len(tanks) >= 2:
            quantities = [t.get("current_quantity", 0) for t in tanks.values()]
            if max(quantities) - min(quantities) > 5.0:
                factors.append("Fuel imbalance between tanks")

        # Configuration issues
        if not impact_snapshot.control_inputs.get("gear", True):
            factors.append("Landing gear retracted at impact (increases damage)")

        if impact_snapshot.control_inputs.get("flaps", 0) < 0.5:
            factors.append("Flaps not deployed for landing (higher touchdown speed)")

        # Electrical issues
        electrical = failure_snapshot.electrical_state
        if electrical.get("battery_soc_percent", 100) < 20:
            factors.append("Low battery state of charge")

        # Speed issues
        if impact_snapshot.airspeed_knots < 50:
            factors.append("Airspeed below safe minimum at impact")
        elif impact_snapshot.airspeed_knots > 100:
            factors.append("Excessive airspeed at impact")

        return factors

    def _calculate_impact_force(self, impact_snapshot: FailureSnapshot) -> float:
        """Calculate impact G-force.

        Simplified calculation based on vertical speed and deceleration time.
        Real calculation would use velocity change and impact duration.
        """
        # Convert vertical speed to ft/s
        vs_fps = impact_snapshot.vertical_speed_fpm / 60.0

        # Assume deceleration over 0.1 seconds (hard impact)
        # Soft impact (gear, flaps) would be 0.5+ seconds
        decel_time = 0.3 if impact_snapshot.control_inputs.get("gear", False) else 0.1

        # Calculate deceleration
        deceleration_fps2 = abs(vs_fps) / decel_time

        # Convert to G-force
        g_force = deceleration_fps2 / 32.2  # 32.2 ft/s² = 1 G

        return g_force

    def _assess_survivability(
        self, impact_g: float, impact_snapshot: FailureSnapshot
    ) -> SurvivabilityLevel:
        """Assess impact survivability based on G-forces and configuration."""
        # G-force thresholds
        if impact_g > 20.0:
            return SurvivabilityLevel.UNSURVIVABLE
        elif impact_g > 10.0:
            return SurvivabilityLevel.LIKELY_FATAL
        elif impact_g > 5.0:
            return SurvivabilityLevel.SERIOUS_INJURY
        elif impact_g > 2.0:
            return SurvivabilityLevel.MINOR_INJURY
        else:
            return SurvivabilityLevel.SURVIVABLE

    def _generate_lessons(
        self,
        failure_type: FailureType,
        failure_snapshot: FailureSnapshot,
        impact_snapshot: FailureSnapshot,
        warnings: list[tuple[float, str]],
    ) -> list[str]:
        """Generate lessons learned for pilot education."""
        lessons = []

        # Fuel exhaustion lessons
        if failure_type == FailureType.FUEL_EXHAUSTION:
            lessons.append("Always monitor fuel gauges and plan with 30-minute reserve minimum")
            lessons.append("Respond immediately to low fuel warnings")
            lessons.append("Land at nearest suitable airport when fuel reaches reserve level")
            if len(warnings) > 0:
                lessons.append(f"You received {len(warnings)} warning(s) - DO NOT ignore warnings")

        # Engine failure lessons
        elif failure_type == FailureType.ENGINE_FAILURE:
            lessons.append("Immediately establish best glide speed (65 knots for Cessna 172)")
            lessons.append("Pick suitable landing site within gliding distance")
            lessons.append("Attempt engine restart only if altitude permits")
            lessons.append("Declare emergency on 121.5 MHz if able")
            lessons.append("Maintain aircraft control - fly the airplane first")

        # CFIT lessons
        elif failure_type == FailureType.CONTROLLED_FLIGHT_INTO_TERRAIN:
            lessons.append("Maintain situational awareness of terrain and altitude")
            lessons.append("Use terrain awareness systems if available")
            lessons.append("Maintain safe altitude above terrain (500-1000 ft AGL minimum)")
            lessons.append("Never descend below minimum safe altitude in IMC")

        # Stall/spin lessons
        elif failure_type == FailureType.STALL_SPIN:
            lessons.append("Maintain airspeed above stall speed at all times")
            lessons.append("Coordinate turns with rudder - no skidding or slipping")
            lessons.append("Recover from stall immediately: nose down, full power, level wings")
            lessons.append("Never stall in a turn - spin entry is likely and fatal at low altitude")

        # Landing technique lessons
        if abs(impact_snapshot.vertical_speed_fpm) > 600:
            lessons.append("Flare more aggressively to reduce descent rate below 200 fpm")
            lessons.append("Practice soft-field landings to improve touchdown technique")

        # Configuration lessons
        if not impact_snapshot.control_inputs.get("gear", True):
            lessons.append("ALWAYS extend landing gear for landing (check GUMPS checklist)")
            lessons.append("Gear-down absorbs landing energy and prevents airframe damage")

        if impact_snapshot.control_inputs.get("flaps", 0) < 0.5:
            lessons.append("Deploy full flaps for landing to reduce touchdown speed")

        return lessons

    def generate_report(self, analysis: FailureAnalysis) -> str:
        """Generate human-readable failure report.

        Args:
            analysis: FailureAnalysis from analyze_failure()

        Returns:
            Formatted multi-line report string
        """
        report = []
        report.append("=" * 60)
        report.append("FLIGHT FAILURE ANALYSIS")
        report.append("=" * 60)
        report.append("")

        # Failure classification
        report.append(f"Failure Type: {analysis.failure_type.value.upper().replace('_', ' ')}")
        report.append(f"Primary Cause: {analysis.primary_cause}")
        report.append("")

        # Time and location
        fs = analysis.failure_snapshot
        report.append(f"Time of Failure: {fs.time.strftime('%Y-%m-%d %H:%M:%S UTC')}")
        report.append(f"Location: {fs.position[0]:.4f}° N, {fs.position[1]:.4f}° W")
        report.append(f"Altitude at Failure: {fs.position[2]:.0f} ft MSL")
        report.append(f"Airspeed: {fs.airspeed_knots:.0f} knots")
        report.append("")

        # Contributing factors
        if analysis.contributing_factors:
            report.append("Contributing Factors:")
            for factor in analysis.contributing_factors:
                report.append(f"  - {factor}")
            report.append("")

        # Impact state
        imp = analysis.impact_snapshot
        report.append("Impact State:")
        report.append(f"  Ground speed: {imp.ground_speed_knots:.0f} knots")
        report.append(f"  Descent rate: {imp.vertical_speed_fpm:.0f} ft/min")
        report.append(f"  Attitude: Pitch {imp.pitch:.0f}°, Roll {imp.roll:.0f}°")
        report.append(f"  Impact force: {analysis.impact_force_g:.1f} G")
        report.append(f"  Survivability: {analysis.survivability.value.upper().replace('_', ' ')}")
        report.append("")

        # Lessons learned
        report.append("Lessons Learned:")
        for i, lesson in enumerate(analysis.lessons_learned, 1):
            report.append(f"  {i}. {lesson}")
        report.append("")

        # Flight duration
        duration = timedelta(seconds=int(analysis.flight_duration))
        hours = duration.seconds // 3600
        minutes = (duration.seconds % 3600) // 60
        seconds = duration.seconds % 60
        if hours > 0:
            time_str = f"{hours}:{minutes:02d}:{seconds:02d}"
        else:
            time_str = f"{minutes}:{seconds:02d}"
        report.append(f"Total Flight Time: {time_str}")
        report.append("")

        report.append("=" * 60)

        return "\n".join(report)
